一句话总结我们的策略是：**文件存放在服务器硬盘上，文件的描述信息和索引存在数据库里。** 我们需要用到两种“数据库”：一个是我们已经创建的**关系型数据库 (`app.db`)**，另一个是用于AI检索的**向量数据库**。

---

### 1. 资源（文件）如何存储？

对于用户上传的教学资源文件（如 PDF, Word文档, Markdown等），**最佳实践是不要将文件本身直接存入数据库**。这样做效率低下，且会使数据库变得异常臃肿。

**正确的方法是：**

1.  在 `backend` 目录下创建一个专门的文件夹，例如 `resource_files/`。
2.  当老师上传一个文件时，后端程序将该文件保存在这个文件夹里。为了避免重名，最好使用文件的唯一ID或者UUID来重命名文件。
3.  **我们只在数据库中存储这个文件的元数据（metadata）**，比如它的原始文件名、存储路径、上传者、所属课程、上传时间等。

### 2. 我们需要更多的数据库表吗？

**是的，绝对需要。** `app.db` 目前只有一个 `user` 表，这远远不够。为了实现文件管理和教学大纲生成的功能，我们至少还需要增加两个核心的表：`Course`（课程）和 `Document`（文档）。

**这是我建议的表结构设计：**

*   **`User` 表 (已存在)**
    *   `id` (主键)
    *   `username`
    *   `password_hash`
    *   `role` (教师, 学生, 管理员)

*   **`Course` 表 (课程表 - **需要新建**)**
    *   `id` (主键)
    *   `name` (课程名称, 如 "大学物理第一学期")
    *   `description` (课程描述)
    *   `teacher_id` (外键, 关联到 `User` 表的 `id`，表示这门课是哪个老师的)

*   **`Document` 表 (文档资源表 - **需要新建**)**
    *   `id` (主键)
    *   `original_filename` (用户上传时的原始文件名)
    *   `storage_path` (文件在服务器上的存储路径, 如 `resource_files/xxxxx.pdf`)
    *   `file_type` (文件类型, 如 'pdf', 'docx')
    *   `upload_date` (上传日期)
    *   `status` (处理状态, 如 '已上传', '处理中', '已完成')
    *   `course_id` (外键, 关联到 `Course` 表的 `id`，表示这个文件属于哪门课)

这三个表的关系是：一个 `User` (老师) 可以拥有多个 `Course`，一个 `Course` 可以包含多个 `Document`。

### 3. 我们还需要“向量数据库”

这是实现AI功能的核心。关系型数据库（如`app.db`）擅长精确查找（例如，找到ID为5的用户），但它**无法理解文本的含义**。

为了让AI能“阅读”并理解你上传的文档内容，我们需要一个**向量数据库**。

**工作流程如下：**
1.  **处理文档**：当一个文件被上传后，后端程序会把它读取出来，切割成一个个小的文本块（Chunks）。
2.  **生成向量**：程序会调用一个深度学习模型（Embedding Model），将每一个文本块都转换成一个由数字组成的“向量”（可以理解为文本的“数学指纹”）。
3.  **存入向量库**：这些向量，连同它们对应的原始文本块，被存入向量数据库中。

当老师提出要求（例如“根据我上传的《热力学定律》和《分子运动论》两个文件，生成一份教学大纲”）时，系统会：
1.  将老师的这个要求也转换成一个向量。
2.  在向量数据库中进行**语义搜索**，找出与老师要求最“相似”的那些文本块的向量。
3.  把这些最相关的文本块作为上下文（Context），连同老师的原始要求一起，发送给大语言模型（LLM）。
4.  LLM 参考这些高度相关的上下文，最终生成一份高质量的教学大纲。

对于本地开发，有很多轻量级的向量数据库方案，例如 `ChromaDB` 或 `FAISS`，它们甚至可以直接将索引保存在硬盘文件里，和 `SQLite` 的使用体验很相似。

### 4. 用什么应用来管理这些表？

对于管理 `app.db` (SQLite数据库) 里的表和数据，我强烈推荐一个**免费、开源且非常好用的图形化工具**：

*   **DB Browser for SQLite**

您可以从它的官网下载。使用它，您只需要：
1.  点击 "Open Database"。
2.  选择我们项目中的 `backend/app.db` 文件。
3.  然后您就可以非常直观地看到里面有哪些表、表的结构是什么样的，以及表里存储了哪些数据。您可以像使用 Excel 一样浏览、搜索和修改数据，这对开发和调试非常有帮助。


**文件上传与处理流程**

Ran tool
这个图表清晰地展示了我们的策略：

1.  **用户操作**：老师在浏览器上传文件。
2.  **后端接收**：Flask 应用接收到请求。
3.  **兵分三路**：
    *   **原始文件**被直接存入服务器的硬盘中。
    *   **文件的描述信息**（元数据）被存入我们的 `app.db` 关系型数据库中（需要新建 `Course` 和 `Document` 表）。
    *   **文件的内容**经过AI处理后，以向量的形式存入专门的向量数据库，为后续生成大纲的功能做准备。

